from header_file import *
from polynomialtrajectory import MinimalTrajectoryGenerator as MinTrajGen
import numpy as np
from rrtstar import RRTStar
from rrtstarplotter import RRTPlotter
from obstacle import Obstacle

rrt_waypoints = [];
true_rrt_tree = [];
def main():
    global rrt_waypoints
    global true_rrt_tree
    main_waypoints = np.array([[2.48, -1.08, 1.0], [0.8, -2.0, 1.0], [-2.15, 0.03, 1.0], [-1.18, 1.03, 1.0], [0.75, 1.95, 1.0], [1.73, 1.03, 1.0], [0.8, 0.03, 1.0], [0.83, -0.95, 1.0], [2.48, -1.08, 1.0]])
    rrt = build_rrt(main_waypoints, run=False)
    rrt_waypoints = read_data("rrt_path.csv")
    durations = np.ones(13)*3
    derivative = Derivative.JERK
    minimal_jerk_trajectory = generate_trajectory(rrt_waypoints, durations, derivative)
    
    plot_rrt(rrt, main_waypoints, minimal_jerk_trajectory)
    derivative = Derivative.SNAP
    minimal_snap_trajectory = generate_trajectory(rrt_waypoints, durations, derivative)
    plot_rrt(rrt, main_waypoints, minimal_snap_trajectory)

def plot_rrt(rrt, main_waypoints, optimal_trajectory=None, real_trajectory=None):
    rrtplotter = RRTPlotter(rrt, optimal_trajectory, real_trajectory)
    rrtplotter.set_rrt_path(rrt_waypoints)
    rrtplotter.plot_waypoints(waypoints=main_waypoints)
    rrtplotter.plot_path()
    rrtplotter.plot_obstacles()
    rrtplotter.plot_trajectory()
    rrtplotter.plot_executed_trajectory()
    rrtplotter.display_plots()

def build_rrt(main_waypoints, run=True):
    rrt = RRTStar()
    obstacle1 = Obstacle([-1.3, -1.4, 0.0, -0.3, -0.4, 1.0])
    obstacle2 = Obstacle([-0.65, 1.05, 0.0, 0.35, 2.05, 1.0]).rotate(25, 0, 0)
    floor = Obstacle([-2.5, -2.5, -0.1, 2.5, 2.5, 0.0])
    rrt.add_obstacles([obstacle1, obstacle2, floor])
    rrt.set_max_step(0.1)
    rrt.set_boundaries([-3, -3, 0, 3, 3, 5])
    if run is True:
        for i in range(len(main_waypoints) - 1):
            rrt.set_start_and_goal(main_waypoints[i], main_waypoints[i + 1])
            rrt.run()
            rrt_waypoints.append(rrt.get_best_path())
            true_rrt_tree.append(rrt.get_best_tree())
            rrt.reset()
    return rrt
    
    #rrt_plottingn(waypoints)
    #plotter = Plotter()    
    #generate_trajectory(plotter)
    #plot_trajectory(plotter)


def generate_trajectory(waypoints, durations, order):
    generator = MinTrajGen(waypoints=waypoints, durations=durations, minimal_trajectory_order=order)
    generator.set_maximum_velocity(3)
    generator.set_dt(0.05)
    generator.create_poly_matrices()
    generator.compute_splines()
    return generator.get_splines()

def save_optimal_trajectory(trajectory: np.ndarray, order: Derivative):
    save_data(f"rrt_trajectory_{order.name.lower()}.csv", trajectory)
    

if __name__ == "__main__":
    main()
    

    
def plot_trajectory(Derivative: Derivative, control: str):
    plotter = Plotter()
    trajectory = plotter.read_data("Minimal_jerk_trajectory_for_pipelines.csv")
    waypoints = plotter.read_data("Waypoints.csv")
    durations = plotter.read_data("Durations.csv")
    drone_path = plotter.read_data("drone_path_jerk_OIAC.csv")
    drone_force_and_torque = plotter.read_data("drone_force_and_torque_snap_OIAC.csv")
    drone_k_values = plotter.read_data("drone_K_values_snap.csv")
    drone_d_values = plotter.read_data("drone_D_values_snap.csv")

    #plot_KD_Terms(plotter, waypoints, durations, drone_k_values, "K")
    #plot_KD_Terms(plotter, waypoints, durations, drone_d_values, "D")
    #find_KD_values(drone_k_values, drone_d_values)
    #plot2D_drone_path(plotter, trajectory, waypoints, durations, drone_path, Derivative.JERK, "OIAC")
    #plot_drone_force_and_torque(plotter, waypoints, durations, drone_force_and_torque, Derivative.JERK, "OIAC")
    #plot_2D_distance_error(plotter, trajectory, drone_path, waypoints, durations, Derivative.JERK, "OIAC")

def plot2D_drone_path(plotter, trajectory, waypoints, durations, drone_path, derivative_data, controller):
    plotter.initialize(trajectory, waypoints, durations, derivative_data)
    plotter.append_title_name(f"with drone path {controller}")
    plotter.plot_2d_trajectory(label = "Trajectory")
    plotter.plot_2d_waypoints()
    plotter.set_trajectory(drone_path)
    plotter.plot_2d_trajectory(label = f"drone path {controller}")
    plotter.display_labels_2d(save_plot = True)

def plot_drone_force_and_torque(plotter, waypoints, durations, drone_force_and_torque, derivative_data, controller):
    plotter.initialize(drone_force_and_torque, waypoints, durations, derivative_data)
    plotter.add_other_data(drone_force_and_torque[:, 3],f"{controller} Minimal {str(derivative_data.name).lower()} throttle")
    plotter.set_title(f"Minimal {str(derivative_data.name).lower()} throttle {controller}")
    plotter.plot_other_data_vs_time(index=0)
    plotter.add_other_data(drone_force_and_torque[:, 0],f"{controller} Minimal {str(derivative_data.name).lower()} Roll")
    plotter.add_other_data(drone_force_and_torque[:, 1],f"{controller} Minimal {str(derivative_data.name).lower()} Pitch")
    plotter.add_other_data(drone_force_and_torque[:, 2],f"{controller} Minimal {str(derivative_data.name).lower()} Yaw")
    plotter.set_title(f"Minimal {str(derivative_data.name).lower()} moments {controller}")
    plotter.plot_other_data_vs_time(index=range(1, 4))

def find_KD_values(kval, dval):
    find_KD_minmaxmean("K throttle", kval, "K xy", "K rpy")
    find_KD_minmaxmean("D throttle", dval, "D xy", "D rpy")


def find_KD_minmaxmean(arg0, arg1, arg2, arg3):
    minmaxmean(arg0, arg1[:, 0])
    minmaxmean(arg2, arg1[:, 1:3])
    minmaxmean(arg3, arg1[:, 3:6])

def minmaxmean(name, data):
    print(f"{name} Max: {np.max(data)}")
    print(f"{name} Min: {np.min(data)}")
    print(f"{name} Avg: {np.mean(data)}")

def plot_KD_Terms(plotter: Plotter, waypoints, durations, data, letter):
    plotter.initialize(data, waypoints, durations)
    plotter.set_title(f"Minimal jerk trajectory with Drone {letter} values for throttle")
    plotter.add_other_data(other_data=data[: , 0], name=f"{letter} values for throttle")
    plotter.plot_other_data_vs_time(index=0)
    plotter.set_title(f"Minimal jerk trajectory with Drone {letter} values for x and y")
    plotter.add_other_data(other_data=data[: , 1], name=f"{letter} values for outer loop x")
    plotter.add_other_data(other_data=data[: , 2], name=f"{letter} values for outer loop y")
    plotter.plot_other_data_vs_time(index=[1, 2])
    plotter.set_title(f"Minimal jerk trajectory with Drone {letter} values for roll, pitch and yaw")
    plotter.add_other_data(other_data=data[: , 3], name=f"{letter} values for inner loop roll")
    plotter.add_other_data(other_data=data[: , 4], name=f"{letter} values for inner loop pitch")
    plotter.add_other_data(other_data=data[: , 5], name=f"{letter} values for inner loop yaw")
    plotter.plot_other_data_vs_time(index=range(3, 6))
    
def plot_2D_distance_error(plotter: Plotter, trajectory, drone_path, waypoints, durations, derivative: Derivative, controller):
    plotter.initialize(trajectory, waypoints, durations, derivative)
    plotter.set_title(f"Minimal {derivative.name.lower()} distance error for drone path {controller}")
    plotter.plot_2D_distance_error(trajectory, drone_path, save_plot=True)