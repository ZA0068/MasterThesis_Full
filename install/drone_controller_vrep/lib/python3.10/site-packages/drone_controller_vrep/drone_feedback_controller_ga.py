import rclpy
from rclpy.node import Node
from geometry_msgs.msg import TwistStamped, PoseStamped, Vector3, Quaternion, Point
import rclpy.publisher
from std_msgs.msg import Float64, Bool, Int32
from tf_transformations import euler_from_quaternion
from .online_impedance_adaptive_controller import OIAC
from .header_file import TrajectoryState
import numpy as np
import pygad
import multiprocessing
import matplotlib.pyplot as plt
import subprocess
import time

def plot_results(ga_instance):
    # Assuming 'ga_instance' has a 'fitness' attribute or similar
    # This is pseudocode; adapt as per actual data structure
    fitness_values = [generation_fitness.max() for generation_fitness in ga_instance.fitness_history]
    plt.plot(fitness_values)
    plt.title("Fitness Over Generations")
    plt.xlabel("Generation")
    plt.ylabel("Fitness")
    plt.show()
    
class DroneFeedbackController(Node):
    @staticmethod
    def quaternion_to_euler(quaternion: Quaternion) -> tuple:
        euler =  euler_from_quaternion([
            quaternion.x,
            quaternion.y,
            quaternion.z,
            quaternion.w
        ])
        return Vector3(x=euler[0], y=euler[1], z=euler[2])
        
    def __init__(self, controller_params, port):
        super().__init__('drone_feedback_controller')
        self._port = port
        self.reset()
        self.set_parameters(controller_params)
        self._init_OIAC_controller()
        self._init_pubsub()
        self._init_state()


    def set_parameters(self, controller_params):
        if len(controller_params) != 9:
            raise ValueError("Controller parameters must be of length 9")
        self.__params = controller_params
    
    def _init_state(self):
        self.__state = TrajectoryState.START


    def _init_OIAC_controller(self):
        self.throttle = OIAC(self.__params[0], self.__params[1], self.__params[2])
        self.throttle.set_feedforward([5.45])
        self.throttle.set_saturation(-1, 2)
        self.outer_loop = OIAC(self.__params[3], self.__params[4], self.__params[5])
        self.outer_loop.set_saturation(-1, 1)
        self.inner_loop = OIAC(self.__params[6], self.__params[7], self.__params[8])
        self.inner_loop.set_saturation(-1, 1)

    def _init_pubsub(self):
        suffix = f'_{str(self._port)}'
        self.pose_subscriber = self.create_subscription(
            PoseStamped, f'Current_position{suffix}', self.pose_callback, 10
        )
        self.velocity_subscriber = self.create_subscription(
            TwistStamped, f'Current_velocity{suffix}', self.velocity_callback, 10
        )
        self.local_attitude_subscriber = self.create_subscription(
            Vector3(),
            f'Current_local_attitude{suffix}',
            self.local_attitude_callback,
            10,
        )
        self.simulation_state_subscriber = self.create_subscription(
            Int32(), f'simulationState{suffix}', self.simulation_state_callback, 10
        )
        self.thrust_publisher = self.create_publisher(Float64, f'Thrust{suffix}', 10)
        self.outer_loop_publisher = self.create_publisher(Vector3, f'Attitude{suffix}', 10)
        self.simulation_publisher_start = self.create_publisher(Bool, f'startSimulation{suffix}', 10)
        self.simulation_publisher_stop = self.create_publisher(Bool, f'stopSimulation{suffix}', 10)
        self.control_timing = self.create_timer(0.05, self.controller_callback)


    def reset(self):
        self._vx = 0.0
        self._vy = 0.0
        self._position = None
        self._orientation = None
        self._velocity = None
        self._angular_velocity = None
        self._thrust = None
        self._torque = None
        self.__error = 0.0
        self._rp = [0.0, 0.0, 0.0]
        self._twist = [0.0, 0.0, 0.0]
        self.__trajectory = np.array([[-2.0, -2.0, 2.0]])
        self._max_timestep = 1
        self._timer = 0
        self._count_up = True
        self.__finished = False
        self._enable_data_storage = False
        self._use_min_dist = False
        self._min_dist = 0.5
        self.__crashed = False
        self.__simstate = 0
        self._position = Point()
        self._orientation = Vector3()
        self._velocity = Vector3()
        self._angular_velocity = Vector3()
        self._thrust = Float64()
        self._torque = Vector3()


    def controller_callback(self):
        print(f"Controller callback {self._port}")
        match self.__state:
            case TrajectoryState.START:
                self.start_simulation()
            case TrajectoryState.RUNNING:
                self.fly_drone()
                self.check_if_close()
            case TrajectoryState.STOP:
                self.__finished = True

    def set_trajectory(self, trajectory: np.ndarray):
        self.__trajectory = trajectory

    def check_if_close(self):
        if self.is_under_min_dist(0.05):
            self.__state = TrajectoryState.STOP
        else:
            self._timer += 1

    def simulation_state_callback(self, msg):
        self.__simstate = msg.data

    def fly_drone(self):
        print(f"flying, simulation state:{self.__simstate}")
        self.run_controller()
        self.assign_torque_values()
        self.publish_data()
        self.check_out_of_control()

    def is_under_min_dist(self, threshold):
        return self.__error < threshold

    def publish_data(self):
        self.thrust_publisher.publish(self._thrust)
        self.outer_loop_publisher.publish(self._torque)

    def assign_torque_values(self):
        self._torque.x = -self._twist[0]
        self._torque.y = self._twist[1]
        self._torque.z = -self._twist[2]

    def run_controller(self):
        self._rp = self.outer_loop.run_OIAC([self._position.x, self._position.y], self.__trajectory[0, :2], [self._velocity.x, self._velocity.y], [0.0, 0.0]).ravel()
        self._twist = self.inner_loop.run_OIAC([self._orientation.x, self._orientation.y, self._orientation.z], [-self._rp[1], self._rp[0], 0.0], [self._angular_velocity.x, self._angular_velocity.y, self._angular_velocity.z], [0.0, 0.0, 0.0])
        self._thrust.data = self.throttle.run_OIAC(self._position.z, self.__trajectory[0, 2], self._velocity.z, 0.0).ravel()[0]


    def pose_callback(self, msg):
        self._position = msg.pose.position
        self._orientation = self.quaternion_to_euler(msg.pose.orientation)

    def velocity_callback(self, msg):
        self._velocity = msg.twist.linear
        self._angular_velocity = msg.twist.angular

    def local_attitude_callback(self, msg):
        self._vx = msg.x - msg.z
        self._vy = msg.y - msg.z

    def start_simulation(self):
        command = [
            'ros2', 'topic', 'pub', f'/startSimulation_{self._port}', 
            'std_msgs/msg/Bool', '{data: true}', '--once'
        ]
        print(f"Starting simulation on port {self._port}, simstate: {self.__simstate}")
        subprocess.run(command, capture_output=True, text=True)
        self.__finished = False
        self.__state = TrajectoryState.RUNNING

    def check_out_of_control(self):
        if self.__is_out_of_bounds():
            print(f"Crashed!!! controller no. {self._port}")
            self.__state = TrajectoryState.STOP
            self.__crashed = True
            return
        self.__error = np.linalg.norm(self.__trajectory[0, :3] - np.array([self._position.x, self._position.y, self._position.z]))

    def __is_out_of_bounds(self):
        return self.__x_bound() or self.__y_bounds() or self.__z_bounds() or self.__r_bounds() or self.__p_bounds() or self.__empty_fuel()

    def __x_bound(self):
        return self._position.x < -3 or self._position.x > 3

    def __y_bounds(self):
        return self._position.y < -3 or self._position.y > 3

    def __z_bounds(self):
        return self._position.z < 0 or self._position.z > 20

    def __r_bounds(self):
        return self._orientation.x < -1.2 or self._orientation.x > 1.2

    def __p_bounds(self):
        return self._orientation.y < -1.2 or self._orientation.y > 1.2

    def __empty_fuel(self):
        return self._timer > (20 * 30 * 10)

    def stop_simulation(self):
        print(f"Stopping simulation on port {self._port}, simstate: {self.__simstate}")
        self.simulation_publisher_stop.publish(Bool(data=True))

    def is_finished(self):
        return self.__finished

    def is_crashed(self):
        return self.__crashed

    def get_timer(self):
        return self._timer
    

def compute_fitness(drone_controller):
    crashed = drone_controller.is_crashed()
    timer = drone_controller.get_timer()
    crash_penalty = 9999 if crashed else 0
    return 1000 - (timer + crash_penalty)

def parallel_fitness(pool, ga_instance, solution, solution_idx):
    port = get_port(solution_idx)
    result = pool.apply_async(fitness_function, (solution, solution_idx, port))
    return result.get()

def get_port(solution_idx):
    return 19998 + solution_idx % 4

def ga_fitness_func(pool, ga_instance, solution, idx):
    return pool.apply_async(fitness_function, args=(ga_instance, solution, idx)).get()

# When calling ga_fitness_func, pass 'pool' as an argument
fitness_func=lambda ga_instance, solution, idx: ga_fitness_func(pool, ga_instance, solution, idx)


def fitness_function(ga_instance, solution, idx):
    port = get_port(idx)
    drone_controller = DroneFeedbackController(solution, port)
    try:
        while rclpy.ok() and not drone_controller.is_finished():
            rclpy.spin_once(drone_controller, timeout_sec=0.05)
    finally:
        fitness = compute_fitness(drone_controller)
        drone_controller.stop_simulation()
    return fitness
def fitness_function_wrapper(ga_instance, solution, idx):
    return ga_fitness_func(pool, ga_instance, solution, idx)

def run_genetic_algorithm():
    global pool
    rclpy.init(args=None)
    num_processes = 4
    pool = multiprocessing.Pool(processes=num_processes)
    try:
        ga_instance = pygad.GA(
            num_generations=3,
            num_parents_mating=2,
            fitness_func=fitness_function_wrapper,  # Use the top-level function instead of a lambda
            sol_per_pop=10,
            num_genes=9,
            gene_space=[{'low': -10000.0, 'high': 10000.0}] * 9,
            parent_selection_type="sss",
            crossover_type="single_point",
            mutation_type="random",
            mutation_num_genes=2
        )
        ga_instance.run()
    finally:
        pool.close()
        pool.join()
    rclpy.shutdown()
def on_generation_callback(ga_instance):
    time.sleep(1)  # Delay for 1 second (as an example)

ga_instance = pygad.GA(
    on_generation=on_generation_callback,
    # other parameters as before
)

def main():
    run_genetic_algorithm()

if __name__ == '__main__':
    main()
    
    
# def main(args=None):
#     rclpy.init(args=args)
#     try:
#         drone_controller = DroneFeedbackController([1, 0.2, 5, 4000, 0.1, 0.5, 0.1, 0.1, 1])
#         while rclpy.ok() and not drone_controller.is_finished():
#             rclpy.spin_once(drone_controller, timeout_sec=0.05)
#     except Exception as e:
#         print(e)
#     except KeyboardInterrupt:
#         print("Interrupted by user!!!!")
#     finally:
#         drone_controller.stop_simulation()
#         drone_controller.destroy_node()
#         rclpy.shutdown()

# if __name__ == '__main__':
#     main()